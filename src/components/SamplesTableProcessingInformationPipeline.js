import { Box, Heading, Paragraph, Text } from 'grommet'
import isLastIndex from 'helpers/isLastIndex'
import { links } from 'config'
import { Anchor } from 'components/Anchor'
import { SamplesTableProcessingInformationPipelineSteps } from 'components/SamplesTableProcessingInformationPipelineSteps'
import { SamplesTableProcessingInformationSubmitterSupplied } from 'components/SamplesTableProcessingInformationSubmitterSupplied'
import { SamplesTableProcessingInformationVersion } from 'components/SamplesTableProcessingInformationVersion'

const Description = ({ name, description }) => (
  <>
    <Box margin={{ bottom: 'xsmall' }}>
      <Heading level={2} size="small">
        {name}
      </Heading>
    </Box>
    <Paragraph>{description}</Paragraph>
  </>
)

const AffymetrixScan = () => {
  const name = 'SCAN'
  const description = (
    <>
      SCAN (Single Channel Array Normalization) is a normalization method for
      single channel (Affymetrix) microarrays that allows us to process
      individual samples. SCAN models and corrects for the effect of technical
      bias, such as GC content, using a mixture-modeling approach. For more
      information about this approach, see the primary publication (Piccolo, et
      al. <i>Genomics</i>. 2012.{' '}
      <Anchor
        href={links.doi_scan}
        label={`DOI: ${links.doi_scan.substring(15)}`}
        target="_blank"
        rel="noopener noreferrer"
      />
      ){' '}
      <Text>
        and the SCAN.UPC bioconductor package documentation (
        <Anchor
          href={links.doi_scan_upc_bioconductor_docs}
          label={`DOI: ${links.doi_scan_upc_bioconductor_docs.substring(16)}`}
          target="_blank"
          rel="noopener noreferrer"
        />
        ).
      </Text>
    </>
  )

  return <Description name={name} description={description} />
}

const IlluminaScan = () => {
  const name = 'SCAN'
  const description = (
    <>
      SCAN (Single Channel Array Normalization) is a normalization method for
      single channel microarrays that allows us to process individual samples.
      It was originally developed for Affymetrix microarrays. In our system, it
      has been adapted for Illumina BeadArrays. SCAN models and corrects for the
      effect of technical bias, such as GC content, using a mixture-modeling
      approach. For more information about this approach, see the primary
      publication (Piccolo, et al. <i>Genomics</i>. 2012.{' '}
      <Anchor
        href={links.doi_scan}
        label={`DOI: ${links.doi_scan.substring(15)}`}
        target="_blank"
        rel="noopener noreferrer"
      />
      ).
    </>
  )

  return <Description name={name} description={description} />
}

const Salmon = () => {
  const name = 'Salmon'
  const description = (
    <>
      Salmon is an alignment-free method for estimating transcript abundances
      from RNA-Seq data. We use it in quasi-mapping mode, which is significantly
      faster than alignment-based approaches and requires us to build a Salmon
      transcriptome index. We build a custom reference transcriptome (using RSEM
      rsem-prepare-reference) by filtering the Ensembl genomic DNA assembly to
      remove pseudogenes, which we expect could negatively impact the
      quantification of protein-coding genes. This means we're obtaining
      abundance estimates for coding as well as non-coding transcripts. We
      include the flags <i>--seqBias</i> to correct for random hexamer priming
      and, if this is a paired-end experiment, <i>--gcBias</i> to correct for GC
      content when running <i>salmon quant</i>.{' '}
      <Anchor
        href={links.salmon_quant}
        label="Learn more"
        target="_blank"
        rel="noopener noreferrer"
      />
    </>
  )

  return <Description name={name} description={description} />
}

const Txtimport = () => {
  const name = 'Tximport'
  const description = (
    <>
      <i>tximport</i> imports transcript (tx)-level abundance estimates
      generated by
      <i>salmon quant</i> and summarizes them to the gene-level. We use the tx
      to gene mapping generated as part of our reference transcriptome
      processing pipeline. Our tximport implementation generates{' '}
      <Anchor
        href={links.r_docs_tximport}
        label='"lengthScaledTPM"'
        target="_blank"
        rel="noopener noreferrer"
      />
      , which are gene-level count-scale values that are generated by scaling
      TPM using the average transcript length across samples and to the library
      size. Note that tximport is applied at the <em>experiment-level</em>{' '}
      rather than to single samples. For additional information, see the{' '}
      <Anchor
        href={links.bioconductor_tximport}
        label="tximport Bioconductor page"
        target="_blank"
        rel="noopener noreferrer"
      />
      , the{' '}
      <Anchor
        href={links.bioconductor_tutorial}
        label={
          <>
            tximport tutorial{' '}
            <em>Importing transcript abundance datasets with tximport</em>
          </>
        }
        target="_blank"
        rel="noopener noreferrer"
      />
      , and{' '}
      <Anchor
        href={links.doi_f100_research_2015}
        label={
          <>
            Soneson, et al. <em>F1000Research.</em> 2015
          </>
        }
        target="_blank"
        rel="noopener noreferrer"
      />
      .
    </>
  )

  return <Description name={name} description={description} />
}

export const SamplesTableProcessingInformationPipeline = ({
  isSubmitterProcessed,
  pipelinesText,
  results,
  sample
}) => {
  const protocols = {
    'Affymetrix SCAN': AffymetrixScan,
    'Illumina SCAN': IlluminaScan,
    MultiQC: null,
    'Salmon Quant': Salmon,
    'Submitter-processed': SamplesTableProcessingInformationSubmitterSupplied,
    'Transcriptome Index': null,
    Tximport: Txtimport
  }

  const getProtocolDescription = (processorName) => {
    const Component = protocols[processorName]

    return !Component ? null : (
      <Component
        isSubmitterProcessed={isSubmitterProcessed}
        results={results}
        sample={sample}
        key={processorName}
      />
    )
  }

  // formats the pipelines' name for UI (e.g., ['Salmon Quant', 'Tximport'] to 'Salmon Quant, and Specimen part')
  const formatPipelinesText = (names) =>
    names.length === 1
      ? names[0]
      : `${names.slice(0, names.length - 1).join(', ')}, and ${
          names[names.length - 1]
        }`

  return (
    <>
      <Box margin={{ bottom: 'medium' }}>
        <Heading level={2} size="small">
          {formatPipelinesText(pipelinesText)}
        </Heading>
        <SamplesTableProcessingInformationPipelineSteps results={results} />
        {results.map(({ processor: { name } }, i, arr) => (
          <Box
            key={name}
            margin={{ bottom: isLastIndex(i, arr) ? 'xsmall' : 'medium' }}
          >
            {getProtocolDescription(name)}
          </Box>
        ))}
        <Paragraph>
          All samples available for download will be{' '}
          <strong>quantile normalized</strong>. For more information regarding
          how quantile normalization is performed and its limitations, see{' '}
          <Anchor
            href={links.refinebio_gitbut_quantile_normalization}
            label="our documentation"
            target="_blank"
            rel="noopener noreferrer"
          />
          .
        </Paragraph>
      </Box>
      <SamplesTableProcessingInformationVersion results={results} />
    </>
  )
}

export default SamplesTableProcessingInformationPipeline
